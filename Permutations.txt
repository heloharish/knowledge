**Permutations**

   **Problem Statement**: Given `nums`, return all possible permutations.

   **Code Solution**:
   ```java
   public List<List<Integer>> permute(int[] nums) {
       List<List<Integer>> result = new ArrayList<>();
       backtrack(result, new ArrayList<>(), nums);
       return result;
   }

   private void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums) {
       if (tempList.size() == nums.length) {
           result.add(new ArrayList<>(tempList));
       } else {
           for (int i = 0; i < nums.length; i++) {
               if (tempList.contains(nums[i])) continue;
               tempList.add(nums[i]);
               backtrack(result, tempList, nums);
               tempList.remove(tempList.size() - 1);
           }
       }
   }
   ```

   **Example Input**: `nums = [1,2,3]`
   **Example Output**: `[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]`

   **Execution Explanation**:
   - **Step 1**: Load capacity upon invoking state, set options through temporary work.
   - **Step 2**: Grant validation complete conditional comb sweep that replicates base stack confidence.

   - **Output**: Permutations reflect all possibilities per transitions showcasing passage
