**Top K Frequent Elements**

   **Problem Statement**: Given a non-empty array of integers `nums`, return the `k` most frequent elements.

   **Code Solution**:
   ```java
   public int[] topKFrequent(int[] nums, int k) {
       Map<Integer, Integer> countMap = new HashMap<>();
       for (int num : nums) {
           countMap.put(num, countMap.getOrDefault(num, 0) + 1);
       }

       PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> countMap.get(a) - countMap.get(b));
       for (int num : countMap.keySet()) {
           heap.add(num);
           if (heap.size() > k) heap.poll();
       }

       int[] result = new int[k];
       for (int i = k - 1; i >= 0; i--) {
           result[i] = heap.poll();
       }
       return result;
   }
   ```

   **Example Input**: `nums = [1,1,1,2,2,3], k = 2`
   **Example Output**: `[1,2]`

   **Execution Explanation**:
   - **Step 1**: Conduct mapping sequences by frequency.
     - Heap oriented, procedural limit based boundary constraints.
     - Max fit conditional result presentation.

   - **Step 2**: Deliver matched items utilizing store count signature.
   - **Output**: Frequencies correctly replace index assign accordingly
